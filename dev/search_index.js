var documenterSearchIndex = {"docs":
[{"location":"api/","page":"APIs","title":"APIs","text":"Modules = [FHist]","category":"page"},{"location":"api/#FHist.Hist1D-Tuple{Any, AbstractRange}","page":"APIs","title":"FHist.Hist1D","text":"Hist1D(array, edges::AbstractRange; kwgs...)\nHist1D(array, edges::AbstractVector; error_mode=:sqrt)\n\nCreate a Hist1D with given bin edges and vlaues from array. Weight for each value is assumed to be 1.\n\n\n\n\n\n","category":"method"},{"location":"api/#FHist.Hist1D-Tuple{Any, StatsBase.AbstractWeights, AbstractRange}","page":"APIs","title":"FHist.Hist1D","text":"Hist1D(array, wgts::AbstractWeights, edges::AbstractRange, ; kwgs...)\nHist1D(array, wgts::AbstractWeights, edges::AbstractVector; error_mode=:sqrt)\n\nCreate a Hist1D with given bin edges and vlaues from array. wgts should have the same size as array.\n\n\n\n\n\n","category":"method"},{"location":"api/#FHist.Hist1D-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T","page":"APIs","title":"FHist.Hist1D","text":"Hist1D(A::AbstractVector{T}; nbins::Integer=StatsBase.sturges(length(A)), error_mode=:sqrt) where T\nHist1D(A::AbstractVector{T}, wgts::AbstractWeights; nbins::Integer=StatsBase.sturges(length(A)), error_mode=:sqrt) where T\n\nAutomatically determine number of bins based on Sturges algo.\n\n\n\n\n\n","category":"method"},{"location":"api/#FHist.Hist1D-Union{Tuple{StatsBase.Histogram{T, 1, E}}, Tuple{E}, Tuple{T}} where {T, E}","page":"APIs","title":"FHist.Hist1D","text":"Hist1D(h::Histogram{T, 1, E}; error_mode=:sqrt) where {T,E}\n\nConvert an existing 1D StatsBase.Histogram to a Hist1D. Adds error according to error_mode.\n\n\n\n\n\n","category":"method"},{"location":"api/#FHist.Hist1D-Union{Tuple{}, Tuple{Type{T}}, Tuple{T}} where T","page":"APIs","title":"FHist.Hist1D","text":"Hist1D(elT::Type{T}=Float64; binedges) where {T}\n\nInitialize an empty histogram with bin content typed as T and bin edges. To be used with push!\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.push!-Union{Tuple{E}, Tuple{T}, Tuple{Hist1D{T, E}, Real}, Tuple{Hist1D{T, E}, Real, Real}} where {T, E}","page":"APIs","title":"Base.push!","text":"push!(h::Hist1D, val::Real, wgt::Real=one{T})\n\nAdding one value at a time into histogram. Remember to call update_error! after if you need errors.\n\n\n\n\n\n","category":"method"},{"location":"api/#FHist.update_error!","page":"APIs","title":"FHist.update_error!","text":"update_error!(h::Hist1D, error_fun = sqrt_err)\n\nUpdate the error (up and down) of a histogram according to a specific error_mode. Remember to call this function after updaing a histogram with push!() in a loop.\n\n\n\n\n\n","category":"function"},{"location":"#FHist.jl","page":"Introduction","title":"FHist.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"(Image: Dev) (Image: Build Status) (Image: Codecov)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Fast, error-aware, and thread-safe 1&2D histograms that are also compatible with StatsBase.Histogram","category":"page"},{"location":"#Quick-Start","page":"Introduction","title":"Quick Start","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> a = rand(1000);\n\njulia> h1 = Hist1D(a)\nStatsBase.Histogram{Int64, 1, Tuple{StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}\nedges:\n  0.0:0.1:1.0\nweights: [81, 106, 108, 99, 88, 113, 105, 96, 91, 113]\n...\n...\n\njulia> h2 = Hist1D(Int; bins=0:0.1:1);\n\njulia> Threads.@threads for i in a\n           push!(h2, i)\n       end\n\njulia> update_error!(h2);\n\njulia> h1 == h2\ntrue","category":"page"}]
}
